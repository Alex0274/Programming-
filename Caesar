#include <iostream>
#include <string>
#include <fstream>
#include <limits>
using namespace std;

string lower = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"; // алфавит для строчных букв
string upper = "АБВГДЕЁЖЗИЙКЛМНПОРСТУФХЦЧШЩЪЫЬЭЮЯ"; // алфавит для прописных букв

int len = 33; 										// длина алфавита

int addition(int x, int y) { return x + y; }; 		// функция, возвращающая результат суммы двух чисел
int subtraction(int x, int y) { return x - y; }; 	// функция, возвращающая результат разности двух чисел

/* функция, выполняющая преобразование (метод шифрования / дешифрования Цезаря):
str - исходный текст, shift - величина сдвига, f - функция для суммы / разности двух чисел (для выбора шифрования или дешифрования) */
string CaesarCipher(string str, int shift, int (*f)(int, int))
{
	shift = shift % len;						// значение сдвига с учетом длины алфавита
	string s = str, alphabet;					// новая строка текста = текущей
	for (int i = 0; i < str.length(); i++)		// цикл по всем символам исходного текста		
	{
		if (lower.find(str[i]) != -1)			// если символ - строчная буква, то 
			alphabet = lower;					// использовать алфавит для строчных букв
		else									// иначе (символ - прописная буква)
			alphabet = upper;					// использовать алфавит для прописных букв
		int	position = alphabet.find(str[i]);	// найти позицию текущего символа в алфавите
		if (position != -1)						// если символ принадлежит алфавиту, то 
		{
			int shiftFromStart = position;		// найти сдвиг с начала текста
			int positionFromStart =
				f(shiftFromStart + len,
					shift) % len;		// рассчитать позицию после сдвига с учетом цикличности алфавита
			int index = positionFromStart;		// вычислить индекс символа после сдвига
			s[i] = alphabet[index];				// записать новый символ в результирующую строку текста
		}
	}
	return s;									// вернуть строку с результатом преобразования
}

/* функция для взлома шифра Цезаря: принимает на вход зашифрованную строку текста str, возвращает все допустимые варианты дешифрования */
string CaesarBreaking(string str)
{
	string s;												// результат дешифрования
	string r = "Возможные варианты исходного текста:\n";	// запись заголовка и символа перевода строки к результату дешифрования
	for (int i = 0; i < len; i++)							// цикл по длине алфавита (всем возможным вариантам сдвига)
	{
		s = CaesarCipher(str, i, subtraction);				// выполнить дешифрование и записать в строку s
			r = r + "Величина сдвига: " + to_string(i) +
			"; исходный текст: " + s + "\n"; 			// записать в строку результата с символом перевода строки
	}
	return r;												// вернуть r в качестве результата
}

int main(int argc, char** argv)
{
	system("chcp 1251");							// установка кириллицы в консоли
	string s, 										// строка с исходным текстом 
		r; 										// строка с результатом преобразования 									// строка с именем файла
	int shift, 										// целочисленная величина сдвига для шифра
		key; 										// целочисленная переменная для команды меню
	ifstream infs;									// переменная для открытия текстового файла
	ofstream outfs;									// переменная для записи в текстовый файл
	while (true)									// выполнять в бесконечном цикле следующие действия:
	{
		// вывести меню программы на экран:
		cout << "Меню: " << endl;
		cout << "1 - зашифровать введенный текст" << endl;
		cout << "2 - расшифровать введенный текст с известной величиной сдвига" << endl;
		cout << "3 - расшифровать введенный текст с неизвестной величиной сдвига" << endl;
		cout << "другое число - выход" << endl;
		cout << "Выберите действие: ";
		cin >> key;							// ввод желаемой команды меню
		while (cin.fail())
		{
			cin.clear();
			cin.ignore(cin.rdbuf()->in_avail());;
			cout << "Ошибка ввода, выберите действие: ";
			cin >> key;
		}
		if (key < 1 || key > 3)				// если введенное число не соответствует ни одной команде, 
			break;							// выйти из цикла
		switch (key)							// выбрать блок действий по значению введенного числа:
		{
		case 1:
			cout << "Введите текст для шифрования: ";
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			getline(cin, s);									// ввод строки текста s
			cout << "Введите величину сдвига: ";
			cin >> shift;										// ввод величины сдвига
			while (cin.fail())
			{
				cin.clear();
				cin.ignore(cin.rdbuf()->in_avail());
				cout << "Ошибка ввода, введите целое число: ";
				cin >> shift;
			}
			r = CaesarCipher(s, shift, addition);				// запись шифрованного текста в строку r  
			cout << "Результат шифрования:\n" << r << endl;		// вывод результата шифрования на экран
			break;
		case 2:
			cout << "Введите текст для дешифрования: ";
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			getline(cin, s);									// ввод строки текста s
			cout << "Введите величину сдвига: ";
			cin >> shift;										// ввод величины сдвига
			while (cin.fail())
			{
				cin.clear();
				cin.ignore(cin.rdbuf()->in_avail());
				cout << "Ошибка ввода, введите целое число: ";
				cin >> shift;
			}
			r = CaesarCipher(s, shift, subtraction);			// запись дешифрованного текста в строку r  
			cout << "Результат дешифрования:\n" << r << endl;	// вывод результата дешифрования на экран
			break;
		case 3:
			cout << "Введите текст для дешифрования: ";
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			getline(cin, s);									// ввод строки текста s
			r = CaesarBreaking(s);								// взлом шифра Цезаря
			cout << r << endl;									// вывод результатов
			break;
		}
		return 0;
	}
}
